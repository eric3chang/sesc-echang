Figure [num] shows the finite-state machine diagram for a directory, or home memory. Any node will start in the Unowned state. From here, there is only one state transition it can take, and that is to "Unowned/Exclusive Memory-Access." This transition can be triggered by a shared read request or an exclusive read request. While in the "Unowned/Exclusive Memory-Access" state, it is possible for the home memory to receive more shared read requests. It is possible for the home memory to satisfy all these subsequent read requests when the original read request is a shared read, so if any more shared read requests are received, they will also be placed into pending requests.

When the request from memory returns, the home memory could either transition to the Shared state or the Exclusive state, depending on whether or not there are any sharers in addition to the owner. From the Shared state, there are only a few states the directory can transition into. The first is Shared Shared Memory-Access, which occurs if a shared read request comes in while in the Shared state. The home memory will fetch the memory, queuing up any more shared read requests that might come in. When the memory returns, the home memory will send shared replies to all requesters. The home memory could also transition to Shared Exclusive Memory-Access or Exclusive from the Shared state when it receives an exclusive read request, depending on whether or not it needs to fetch the data from memory.

In the Exclusive state, the home memory could transition to the Unowned/Exclusive Memory-Access state if the requester is the owner, whereby the home memory would perform a fetch from memory. However, in this state, it could also transition to two busy states. These two states, Busy-Shared Memory Access, and Busy-Exclusive Memory-Access, are responsible for the transitions to the four other states in the bottom half of the directory FSM diagram. The home memory will transition to the busy memory-access states when the requester is not the owner.

In the Busy-Shared Memory-Access state, we usually would wait for the memory to return before doing anything else. If the home memory receives a memory return first, then it will send an intervention request to the previous owner, and send a speculative reply to the requester, while setting the owner as the requester and transitioning to the Busy-Shared state. Should a writeback request occur before the memory return, however, we would transition to the Busy-Shared Memory-Access Writeback-Request state, where we would wait for the memory return and not send any messages that we would send when we transition to the Busy-Shared state. In the Busy-Shared Memory-Access Writeback-Request state, we would wait for the memory return message, then send a regular shared reply to the owner and a writeback exclusive ack to the requester. The Busy-Exclusive Memory-Access state is similar, except we send exclusive messages instead of shared messages.

In the Busy-Shared state, we are waiting for a message from the previous owner of the block. This could come in the form of a writeback request (if the owner evicted the block before the intervention arrives), a shared writeback, or a shared transfer (no data). If a writeback request comes in, we forward that data to the new owner, and return a writeback busy ack to the requester, while performing a memory write. If a writeback or a transfer comes in, we would perform a memory write if it is a writeback. In either of these two cases, the home memory would transition to a shared state. It is possible for the intervention to be unsuccessful, however, in which case, we would have to resend the intervention. The Busy-Exclusive state is similar, except exclusive messages are sent instead of shared messages.

Figure [num] shows the finite-state machine diagram for a requester, owner, or sharer. When a successful request is returned from the home memory, the node that receives the reply becomes the owner or the sharer. This finite-state machine does not keep track of the actual state of the cache, since that is the job of the cache that is built on top of the directory. This FSM is only responsible for sending and receiving messages to the cache above and to other directories. In other words, it is only responsible for the portion of the requester/owner/sharer that has to interact with the home memory directly. Any potential requester initially starts in the Idle state. This is a non-busy state where the node is waiting for any request to come in. The requests are categorized into two types, based on the location of their states on the diagram. The top half of the diagram are all the states associated with a request that was initiated from the local side, or the cache side. The bottom half of the diagram are all the states that are associated with a request that was initiated from the remote side, or requests from other directories.

When any local requests come in, if the node is not already processing something else, the node will transition to the Wait state, after sending the request to the home memory. In the usual case, the requester will get a return from the home memory, stating that the read request or the write request is successful. These cases are illustrated by the state transitions from the Idle state to the Wait state and back. If it is not successful, the home memory will send a NAK to the requester and the requester will have to resend the request.

The three states on the left side near the top are the states that the requester will go into if the directory is required to perform more actions than the usual case in order to preserve cache coherency for a read request. The first state on the left, "Waiting for Remote Invalidate Acks," occurs when there are other sharers beside the requester, and the requester has to wait for invalidate acks before it can be sure that no other node has the block. The exclusive reply with invalidates pending will have a counter to store how many invalidate acks it should wait for. It is possiblie that an intervention request comes in before all of the invalidate acks have been received by the requester, so we have to be prepared to send a nak in this case.

The two states, "Wait for Remote Response" and "Wait for Remote Speculative Reply," are complements of each other. These two states can happen when the directory is in the Exclusive state. The requester has to wait for two messages before continuing. It has to wait for a message from the home memory, termed speculative reply, and a message from the current owner, which could be a response or an ack (no data). The reason for sending two messages is that there is a possibility that the owner has modified the data, in which case, the only valid copy of the block is the one that the owner has. However, since the owner will only send an ack without data if it has not modified the block, it is necessary for the home memory to send its copy of the data so that the requester can always receive at least one message with data.

On the right side near the top are two states that the requester will go into if the directory is required to perform additional actions for a writeback request. This happens if the writeback request is sent before an intervention request is received by the requester. In this case, the requester has to wait for two messages instead of one in order to get back to the Idle state. The two states are complements of each other. If the requester receives writeback busy ack first, then it will transition to wait for an intervention request; if the requester receives an intervention request first, then it will transition to wait for a writeback busy ack.

The bottom three states in the diagram show the requests that can come in to the owner or sharer from the home memory. These three states can only happen when the node in question already has the block, since the home memory would only contact a node that it thinks has the block. Both "Wait for Local Invalidate Ack" and "Wait for Local Intervention Exclusive Response" states require the sharer to evict the block, while "Wait for Local Intervention Shared Response" allows the sharer to keep the block by sending the data back to the home memory and the requester.
