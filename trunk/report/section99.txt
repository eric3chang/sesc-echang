Include state-transition diagrams for MOESI and for MSI

The MESI protocol adds an "Exclusive" state to reduce the traffic caused by
writes of blocks that only exist in one cache. The MOSI protocol adds an
"Owned" state to reduce the traffic caused by write-backs of blocks that are
read by other caches. The MOESI protocol does both of these things. [copied
from Wikipedia]

CPU1 - CPU2
 |      |
cache   cache
 |         |
memA       memA

If cpu1 and cpu2 are using the same piece of memory, then when cpu1 modifies
memA, cpu2 needs to know that its copy of memA is no longer valid. This is
what a cache coherence protocol does. There are several cache coherence
protocols. [list cache coherence protocols]

There are also several cache coherence mechanisms that enables these cache
coherence protocols to be done.

From wikipedia. We also need to talk about consistency models, which are contracts between thethe system and the programmer. Essentially, these models state that if the programmer follows a specific set of rules, the memory of the system would be consistent with the intentions of the programmers. However, if the programmer does not follow these rules, then the memory would be inconsistent and undeterministic. There are several levels of consistency. Certain processors allow for multiple levels of consistency. For example, Intel's Itanium processor allows for [blah] by using [blah], while using [blah], we can get a higher level of consistency, at the possible expense of a speed loss.

While taking care of cache coherency, we also need to keep in mind that
Amdahl's law prevents us from improving our speedup to a certain degree if our
program contains sequential code. Since sequential code cannot be sped up, we
can never achieve a speedup faster than the time it takes to run that
sequential code.


[Skewed Cache]
Skewed cache is better than regular set-associative cache
(A case for two-way skewed-associative caches)
(Andre Seznec page 4)
