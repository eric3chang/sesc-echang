#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
% This file was converted to LaTeX by Writer2LaTeX ver. 1.0.2
% see http://writer2latex.sourceforge.net for more info

\usepackage{amsfonts}\@ifundefined{definecolor}
 {\usepackage{color}}{}
\usepackage{array}\usepackage{supertabular}\usepackage{hhline}\usepackage{hyperref}\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue}
% Outline numbering

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}
\makeatletter
\newcommand{\arraybslash}{\let\\\@arraycr}
\makeatother
% Page layout (geometry)
\setlength{\voffset}{-1in}
\setlength{\hoffset}{-1in}
\setlength{\topmargin}{1in}
\setlength{\oddsidemargin}{1in}
\setlength{\textheight}{9.036833in}
\setlength{\textwidth}{6.5in}
\setlength{\footskip}{26.148pt}
\setlength{\headheight}{0cm}
\setlength{\headsep}{0cm}
% Footnote rule
\setlength{\skip\footins}{0.0469in}
\renewcommand{\footnoterule}{\vspace*{-0.0071in}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.0071in}}\vspace*{0.0398in}}
% Pages styles
\makeatletter
\newcommand{\ps@Standard}{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{\thepage{}}
  \renewcommand\@evenfoot{\@oddfoot}
  \renewcommand\thepage{\arabic{page}}
}
\makeatother

\setlength{\tabcolsep}{1mm}
\renewcommand{\arraystretch}{1.3}
\newcounter{Figure}
\renewcommand{\theFigure}{\arabic{Figure}}
\title{}
\end_preamble
\use_default_options false
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 2
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title

\series bold
An Analysis of Directory-Based Cache Coherence Protocols on Multiprocessors
 Using the SESC: SuperESCalar Simulator
\end_layout

\begin_layout Author
Eric Chang
\end_layout

\begin_layout Abstract
\noindent

\shape italic
Directory-based cache coherence protocols are based on the central concept
 of having the states of any particular cache block located in a known,
 fixed, location.
 This report will discuss the advantages and disadvantages of two different
 directory-based cache coherence protocols.
 I will first give an overview of all the components in the system.
 Next, I will introduce select components and message types in more detail.
 Then, I will introduce various cache coherence protocols in general, as
 well as the specific protocols that will be compared with each other, which
 are a directory-based cache coherence protocol based on bilateral interactions
 and a different protocol based on the one used in the SGI Origin 2000-based
 systems.
 I will then go into detail about simulating and implementing the differences
 between the protocols using the SESC: SuperESCalar Simulator.
 In addition, results from simulations using SPLASH2 benchmarks are presented.
 We show that the Origin directory-based cache coherence protocol has several
 advantages over the directory-based cache coherence protocol based on bilateral
 interactions.
\end_layout

\begin_layout Section

\family roman
Introduction
\end_layout

\begin_layout Standard
Computers today are moving increasingly towards multiprocessing architectures
 because we have reached a thermal barrier in increasing transistor switching
 speeds.
 As such, it is important to figure out ways to implement effective multiprocess
ing architectures and how schemes offer different tradeoffs between speed
 and memory consistency.
 In particular, the different schemes used for cache coherence by processors
 have a noticeable impact on the performance of a multiprocessing architecture.
 Cache coherence protocols require mechanisms like snoopy buses or directories
 to function.
 Therefore, it is also important to understand how underlying mechanisms
 such as buses and directories allow multiple caches to communicate with
 each other.
\end_layout

\begin_layout Standard
For this purpose, I have made a detailed analysis of the cache coherence
 protocol presented in 
\begin_inset Quotes eld
\end_inset

The SGI Origin: A ccNUMA Highly Scalable Server
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
 In this report, I will go in depth into the Origin system to show how the
 cache coherence protocol in this system operates.
 For comparison, I will also present a detailed analysis about an unoptimized
 protocol based on bilateral interactions, or Bilateral Interaction Protocol
 (BIP).
 Cache coherence protocols based the Origin protocol and BIP are both programmed
 and simulated in the SESC in order to find out which one is faster, and
 why it is faster.
 However, one thing to note is that the Origin 2000 system mentioned in
 the SGI Origin paper is not directly applicable to the CMPs (chip multiprocesso
rs) of today because it was designed for older systems.
 In particular, this system employs distributed shared memory (DSM), in
 which part of the main memory with every node
\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
 More details will be provided in the next section about this situation.
\end_layout

\begin_layout Standard
In the following section of the paper, an overview of how each components
 are connected together to form the complete system is presented.
 Section 3 shows the details of each individual component in the system.
 Section 4 talks about the basic message types that are present in the system.
 Implementation and comparison of protocols is presented in Section 5.
 Performance of the two types of protocols is presented in Section 6.
 Section 7 describes some of the problems faced in simulating the protocols.
 Finally, section 8 concludes the report.
\end_layout

\begin_layout Section
Overview of System
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/connections-origin-protocol.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Connections in the system
\begin_inset CommandInset label
LatexCommand label
name "fig:Connections-in-Origin"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/node-with-hub.emf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Inside the Node
\begin_inset CommandInset label
LatexCommand label
name "fig:Inside-the-Node"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A block diagram of the system is shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Connections-in-Origin"

\end_inset

.
 From the figure, we can see that a network connects identical nodes together
 to form the system.
 The basic building block of this system is the node, which is shown in
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Inside-the-Node"

\end_inset

.
 This system is composed of the hub, the directory, the memory, the L2 and
 L1 cache, and the processor.
 The hub is responsible for directing incoming network messages to the directory
 or to the L2 cache.
 The hub is also responsible for any messages that might be sent between
 the directory and the cache of a single node.
 When the directory sends a message to a local cache, or vice versa, the
 hub will redirect the message to the receiver without sending this message
 on the network.
 The L2 cache is connected to the L1 cache, and the L1 cache to the processor,
 to form the complete node.
\end_layout

\begin_layout Standard
This system is a close approximation of the Origin system, and it will be
 used to run the simulations in the comparison of protocols
\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
 This system uses a DSM, and each memory is addressable from any node.
 If any request arrives at the directory where it is necessary to retrieve
 the memory, the directory is guaranteed to be attached to that memory and
 does not have to ask any other node, since each directory is responsible
 for accessing its own memory.
 This system is not similar to today's systems because it uses a DSM, where
 memory is distributed across each node.
 This is not the case on a modern CMP.
 However, if we consider a CMP where the last-level cache is distributed
 across the nodes (cores) and ignore misses from the last-level cache, then
 the interactions of the protocol becomes similar to what can happen in
 a modern CMP system.
 The individual components in this system will be introduced in more detail
 in the next section.
\end_layout

\begin_layout Section
Components of System
\end_layout

\begin_layout Standard
The most important job of any cache coherence protocols is to maintain data
 coherency.
 In order to maintain data coherency, the protocols all need to make sure
 that whenever a cache writes to its block, it has exclusive access to it.
 Because of that, any cache coherence protocol involves maintaining states
 for the blocks in the caches.
 Each individual cache needs to know the state of its own block, but the
 caches also need to communicate to each other about block states by sending
 messages to each other.
 In a directory-based cache coherence protocol, the directory is responsible
 for storing some of these states.
 I will introduce the cache and the directory in the following sections.
\end_layout

\begin_layout Subsection

\family roman
Cache
\end_layout

\begin_layout Standard
Since the cache is an integral in a coherence protocol, it is important
 to understand what caches are and what kind of requests they can send to
 each other and to the directory.
 
\begin_inset Quotes eld
\end_inset

In a coherent multiprocessor, the caches provide both migration and replication
 of shared data items
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
 It is important for the architect of the processor to design these features
 into the processor to take advantage of the speedup available in having
 multiple blocks of the same data across different nodes, while still giving
 the correct results.
 There are several states that has to be stored by the cache in order to
 enable the rest of the system to function properly.
\end_layout

\begin_layout Standard
The two protocols introduced here serves as an example of some of the protocols
 that can be used to achieve cache coherency.
 I will go over the states stored in the MSI cache protocol first.
 This protocol allows the least amount of information to be stored, yet
 it still provides enough information for a cache to acquire exclusive access.
 An improvement over this protocol can be found in the MESI protocol, which
 adds an 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state to reduce the amount of unnecessary operations in the system.
\end_layout

\begin_layout Subsubsection
MSI Cache
\end_layout

\begin_layout Standard
The MSI protocol is the most basic of the cache coherence protocols, using
 only three states to ensure cache coherency.
 The three letters stand for Modified, Shared, and Invalid.
 The Modified state signifies that the cache block is in a dirty exclusive
 state and that no other cache contains the entry.
 This is necessary whenever the processor needs to perform a write operation.
 The Shared state means that the cache block can exist in caches other than
 the current one, and Invalid means that there are no usable data in this
 particular cache line.
\end_layout

\begin_layout Standard
Because this protocol contains only three states, it can save space on storage
 as compared to some more advanced schemes.
 In addition, the protocol for a cache coherence protocol designed using
 less cache states can be simpler.
 The disadvantage is that this protocol requires more messages and higher
 latency on average as compared to protocols where the cache utilizes more
 states
\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
\end_layout

\begin_layout Subsubsection
MESI Cache
\end_layout

\begin_layout Standard
\begin_inset Float table
placement htbp
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="left" valignment="middle" width="10text%">
<column alignment="left" valignment="middle" width="25text%">
<column alignment="left" valignment="middle" width="25text%">
<column alignment="left" valignment="middle" width="25text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Main Memory 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cache Line 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Other Processor 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stale 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Most recent, correct copy 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hold no copy 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exclusive 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Most recent, correct copy 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Most recent, correct copy 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hold no copy 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shared 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Can hold most recent, correct copy 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Can hold most recent, correct copy 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shared
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Invalid 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
May hold valid or invalid 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Invalid copy 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
May hold valid or invalid copy 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
States in MESI cache
\begin_inset CommandInset label
LatexCommand label
name "tab:States-in-MESI"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The MESI protocol is an improvement upon the MSI protocol in that it adds
 an Exclusive(E) state to the protocol.
 In a system that uses the MESI cache, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tablename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:States-in-MESI"

\end_inset

 illustrates all the states that other components can be in when we have
 knowledge of what the current cache holds.
 The Modified state means that only the cache that holds the block has the
 correct copy, and it has to supply that block to certain requests.
 The Exclusive state means that the main memory and the cache both have
 the same correct copy, so either can respond, depending on the protocol.
 When the block is Shared, all caches that has the block and the main memory
 has the most updated copy.
 When the block is Invalid, the current cache does not know anything about
 the block and does not own the block.
 Whenever a cache holds a block in the Exclusive state, it means that the
 cache has Exclusive access to the block, but had no intention of altering
 the block at the time of request.
 In other words, the Exclusive state indicates a clean exclusive state.
 Adding the Exclusive state is advantageous in that it has the potential
 to reduce traffic when it comes to writes and exclusive read operations.
 A disadvantage of this protocol is that it requires more space to store
 this additional information as compared to the MSI protocol.
\end_layout

\begin_layout Standard
Once we add this state into the protocol, certain cases that required an
 additional request into the network in the MSI protocol becomes an operation
 where no additional messages are emitted.
 For example, the MSI protocol could fill an Exclusive reply as Shared,
 and it would become necessary to send an additional network message to
 request for exclusive ownership when transitioning from Shared to Modified.
 In a MESI cache, since it has the Exclusive state, the same transition
 would go from Exclusive to Modified without emitting any messages on the
 network.
 If instead, the MSI protocol fills an Exclusive reply as Modified, there
 would be situations where we would write a clean block to memory.
 With an additional Exclusive state, the cache does not have to write back
 its block to memory when downgrading from Exclusive to Shared.
 Although directory-based cache coherence protocols can use the MSI cache,
 the MESI cache is the cache that will be used in both of the directory-based
 cache coherence protocols presented in this report.
\end_layout

\begin_layout Subsection
Directory
\end_layout

\begin_layout Standard
The directory is responsible for tracking the state of each cache block
 in order to implement these two operations: 
\begin_inset Quotes eld
\end_inset

handling a read miss and handling a write to a shared, clean cache block
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
 This is necessary since the directory acts as the communication channel
 between each CPU.
 In a snoopy system, we do not keep track of which CPU has which cache block
 in a centralized location.
 This is the advantage in the directory-based cache coherence protocol that
 allows fewer messages to be sent.
 Therefore, it needs to have a list of nodes that have the cache block.
 If we did not store these in the state of the directory, we would have
 to query all the processors to find out what state they are all storing,
 which would be incredibly inefficient.
 It might also be necessary for the directory to store the owners and sharers
 separately in order to find out whether processors own or share a block.
 However, it is not enough to just store the owner and the sharers of the
 block, because there are situations where the directory is in the middle
 of a transaction, and the owner and sharers of the block has not actually
 received the block, yet.
 Such additional states can be used to indicate that the directory is busy
 and cannot fulfill the request at the moment.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cache State 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Directory Data Structure 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified (Dirty Exclusive)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Owner = {P}, Sharers = {}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exclusive (Clean Exclusive)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Owner = {P}, Sharers = {}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shared
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Owner = {P}, Sharers = {Any number of P}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Invalid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Owner = {}, Sharers = {}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\align center
Correspondence between cache state and directory data structure
\begin_inset CommandInset label
LatexCommand label
name "tab:Correspondence-between-cache"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tablename
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Correspondence-between-cache"

\end_inset

 lists the possible data that the directory can hold compared to the cache
 state in any cache that has the block.
 In both the Modified state and the Exclusive state, the directory would
 store only the node ID of the processor that is the owner.
 Nevertheless, the directory does not know for certain whether or not the
 owner is actually clean or dirty until it has sent a request to the cache.
 It is the job of the protocol to take advantage of having the Exclusive
 state by not writing the block to memory if the block is clean.
 If the directory is in a Shared state, then it would have a node ID in
 the owner slot and any number of node IDs in the sharers list.
 The reason that there would be a node ID in the owner slot is because any
 transition into the Shared state must have transitioned from a Modified
 or Exclusive state, which must already have stored a node ID in the owner
 slot.
 If the state of the block is Invalid, there would be no owner or sharers.
\end_layout

\begin_layout Standard
One of the easiest ways to keep track of nodes inside directories is to
 keep a bit vector in each distributed directory about which CPU has which
 cache block.
 Using bit vector to keep track of the CPU that has a specific cache block
 is an efficient way to implement directory-based cache coherence protocol,
 but it has a limit on how many CPUs can be used together with the system
 since the bit vector would grow too large in a system with too many CPUs.
 Another way would be to keep track of the node ID in the directory.
 The advantage of using a node ID is that it can potentially take up less
 space in the directory when we have a large number of processors, since
 we do not have to keep track of all processors.
 However, there is a disadvantage to keeping track of the node ID.
 Usually, in a node ID based directory-based cache coherence system, we
 do not keep track of all the node IDs, because that would defeat the primary
 purpose of using the node IDs, which is to save space.
 Therefore, when we have a system that keeps track of the cache block using
 node ID, we might be unable to keep track of all the CPUs that might potentiall
y request for a cache block.
 In that case, we would have to invalidate a CPU when we want more space
 in the directory.
\end_layout

\begin_layout Standard
Keeping track of the owner could be done by either adding a bit to each
 directory entry, and turning on the extra bit to indicate ownership.
 There could also be an extra entry dedicated to holding the owner.
 The advantage of adding a bit to each directory entry that holds the node
 ID is that it could potentially save bits if there are many nodes in the
 system and each node ID list is short.
 However, using an extra entry strictly for holding the owner is more intuitive,
 and it can also be faster to access since the processor always know which
 entry is the owner.
 We can also have a combined owner-sharers list, where one entry implies
 Exclusive, and multiple entries imply that the directory is in the Shared
 state.
 In this last method, the system would have to be able to quickly scan through
 all the entries it has to determine whether it has no valid entries, one
 valid entry, or multiple valid entries.
 Since in either of the protocols that will be tested in this report, the
 owner entry becomes essentially an additional entry for the sharers list,
 there is not truly a need for the directory to have different slots for
 holding the owner versus a list of sharers.
 Therefore, sometimes in the discussion of protocols in this report, sharers
 will imply both the sharers list and also the node ID in the owner slot.
\end_layout

\begin_layout Section
Message Types
\end_layout

\begin_layout Standard
In this section, I will introduce the basic message types used in the system.
 To begin with, every cache coherence system needs a read request message
 type.
 In a directory-based cache coherence system, this message would be sent
 from the cache to the directory.
 There are two types of read request messages, exclusive and shared.
 The exclusive read request message is sent when the cache receives a write
 from the processor, and the shared read request occurs if the cache receives
 a read from the processor.
 Another message that is similar to the read request message is the intervention
 message, used only by the Origin protocol but not by BIP.
 The intervention message is used to indicate that the exclusive owner,
 whether it owns the block in Clean Exclusive or Dirty Exclusive, should
 give up its block, either by evicting it, or by sending a copy to the requester.
 When the intervention message is shared, the exclusive owner transitions
 to the Shared state, whereas the exclusive owner transitions to the Invalid
 state if the intervention request was exclusive.
 BIP accomplishes the transition out of the exclusive state using a regular
 read message.
\end_layout

\begin_layout Standard
After sending the read request message, the sending cache would wait for
 a response to the read request.
 The four read response types used amongst the two protocols are read response,
 read reply, read ack, and speculative reply.
 A read response indicates a response from another cache, whereas the read
 reply message indicates a response from the memory.
 Since the BIP only supports bilateral interactions between a cache and
 a directory, and never between two caches, there are no read response messages
 sent in the BIP protocol.
 It is also possible for a read ack to be sent, in the case where the block
 does not need to be attached.
 For all three of the read response message types mentioned above, the message
 can be additionally qualified with whether or not it is a response to an
 exclusive or a shared request.
 The final read response type is the speculative reply, used only by the
 directory for sending a block reply in the Origin protocol.
 The speculative reply is used when the directory does not know in advance
 whether or not the owner of the block is in Clean Exclusive or Dirty Exclusive,
 and the directory expects the owner to send its block to the requester,
 as well, if it was in the Dirty Exclusive state.
\end_layout

\begin_layout Standard
The third message type is the writeback request message type.
 There are two types of writeback requests: writeback request and eviction
 request.
 Writeback request is sent when the cache needs to evict a dirty block,
 but it needs to notify the directory and wait for a response before it
 can evict it without causing any possible errors in coherency.
 Eviction request is sent when the cache needs to evict a clean block, and
 it is only used in BIP because the directory in a Origin protocol does
 not need to know when a clean exclusive block is evicted.
\end_layout

\begin_layout Standard
After sending a writeback request or an eviction request, writeback responses
 need to be sent to the requesters.
 The three types of writeback responses are writeback exclusive ack, writeback
 busy ack and eviction ack.
 Writeback busy acks are only used in the Origin protocol and eviction acks
 are only used in BIP.
 Writeback exclusive acks are sent normally by the directory after receiving
 a writeback request.
 However, a writeback busy ack would be used if an intervention message
 arrives after a writeback request was sent.
 Eviction acks would be sent in response to eviction requests.
\end_layout

\begin_layout Standard
Besides the writeback request messages, there are also the writeback and
 transfer messages, used only in the Origin protocol.
 These messages are used whenever an intervention message is sent by the
 directory to the previous owner.
 The previous owner needs to notify the directory that it has received the
 intervention, and it will do so by sending either a writeback message or
 a transfer message.
 A writeback message has the block attached and indicates that the directory
 should write the block to memory.
 A transfer message can be either dirty or shared, depending on whether
 or not the request was exclusive or shared, but it would have no data in
 either case.
\end_layout

\begin_layout Standard
The next message type is invalidate.
 This message is sent whenever an exclusive request arrives when the cache
 block is in the Shared state.
 In this case, the directory needs to invalidate all of the shared block
 by sending invalidates to all of them.
 The caches that receive the invalidate have to send an invalidate ack after
 invalidating their cache.
 Depending on the protocol, the invalidate ack would either go to the directory
 or the cache of the new owner.
\end_layout

\begin_layout Standard
The final message type is the nak message type.
 The nak message is further divided into directory nak message and cache
 nak message, since it is important for the hub to know whether to send
 the nak message to the directory or the cache.
 The nak message is sent whenever the directory or the cache is busy, and
 it cannot process the request at the time.
 The component that receives a nak message would retry its request
\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
\end_layout

\begin_layout Section
Cache Coherence Protocol
\end_layout

\begin_layout Standard
In this section, I will be going into protocol details.
 There are several different types of cache coherence protocols, and each
 of them provide their own advantages and disadvantages.
 I will first introduce the snoopy-based cache coherence protocol.
 Next, I will present directory-based cache coherence protocols in general
 and also show a directory-based cache coherence protocol where all requests
 and replies pass through the home node and each node can only emit one
 response in reply to a request.
 Then, I will be showing a more optimized version of the cache coherence
 protocol, based on the SGI Origin protocol, where it is possible for each
 node to emit two messages in response to a request, and not all requests
 have to pass through the directory before being satisfied.
\end_layout

\begin_layout Subsection
Snoopy-Based Cache Coherence Protocol
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/cache-coherence-protocol-snoopy.wmf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Snoopy-based cache coherence protocol
\begin_inset CommandInset label
LatexCommand label
name "fig:Snoopy-based-cache-coherence"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are many cache coherence protocols that are snoopy-based.
 A simplified diagram of a snoopy-based cache coherence protocol is shown
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Snoopy-based-cache-coherence"

\end_inset

.
 The snoopy-based cache coherence protocol relies on the bus to transfer
 the necessary information.
 In this protocol, there are only two logical nodes, the requesting node
 and the data node.
 However, even though the nodes only need to communicate directly with each
 other, because they are connected by a bus, all messages are broadcast.
 These messages are monitored by each processor and its cache; therefore,
 each processor needs a controller to snoop the bus.
 Anytime a node encounters an important message that pertains to itself,
 the controller makes sure to forward the request to the cache so that it
 can further process it.
 When the processor requires something, it sends its request on the bus,
 and this broadcast message is heard by every processor connected to the
 bus.
\end_layout

\begin_layout Standard
Snoopy-based protocols have an advantage when it comes to manufacturing
 because they can use the existing bus to memory as the broadcast medium
 for communicating information about cache coherence; therefore, manufacturers
 can easily convert single-core processors to be used as multiprocessors.
 However, snoopy-based cache coherence protocols have more problems with
 scaling up to meet higher core counts than directory-based cache coherence
 protocols
\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
 The main problem with scaling up snoopy-based protocols is that all the
 processors are sharing the same medium, the bus.
 Unless the bandwidth and speed of the bus can be scaled infinitely high,
 the number of processors cannot be scaled arbitrarily high.
 For that reason, this report will be focusing mainly on directory-based
 cache coherence protocols.
\end_layout

\begin_layout Subsection
BIP
\end_layout

\begin_layout Standard
Directory-based cache coherence protocols such as the BIP are a class of
 widely used cache coherence protocols that has been proven in the past
 to be able to scale up compared to cache coherence protocols based on the
 snoopy method.
 
\begin_inset Quotes eld
\end_inset

As processor speeds and the number of cores per processor increase, more
 designers are likely to opt for [directory-based cache coherence] protocols
 to avoid the broadcast limit of a snoopy protocol
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
 Directory-based protocols are interesting because it can achieve higher
 speeds performing the same amount of work than snoopy-based protocols.
 Nevertheless, there are still some characteristics of directory-based cache
 coherence protocols that can cause problems when designing a system.
 A snoopy-based protocol has very few problems with consistency because
 all messages are broadcast on a bus, meaning all processors know whenever
 changes occur in the system.
 However, in a directory-based protocol, it is possible for the directory
 to be in an inconsistent state for a longer time.
 For example, when we are evicting a block from a processor, this is broadcast
 across the bus in a snoopy-protocol, and each node knows right away if
 it needs to change its cache state.
 In a directory-based cache coherence protocol, there is some time between
 when the eviction message is sent from the owner to when the message arrives
 at the directory.
 In this time, it is possible for some other request to arrive at the directory,
 allowing the directory to possibly fetch the invalidated data from the
 owner that just evicted its data if care is not taken when designing the
 protocol.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/cache-coherence-protocol-bip.wmf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Protocol based on bilateral interactions
\begin_inset CommandInset label
LatexCommand label
name "fig:Protocol-based-on-bilateral"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A simple request of a directory-based cache coherence protocol based on
 BIP is shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Protocol-based-on-bilateral"

\end_inset

.
 The BIP is a traditional directory-based cache coherence protocol where
 the requester first sends a message to the directory, followed by the directory
 sending another request to the data node, with the data node returning
 a response to the directory.
 Finally, the directory is responsible for forwarding the response back
 to the requester.
 In general, two bilateral interactions occur in this protocol to form a
 complete transaction.
 In the BIP, there are three logical nodes in any request: the requesting
 node, the directory node, and the data node.
 These logical nodes can all be the same physical nodes or they can all
 be different, but it is easier to think of them logically as three separate
 nodes.
 Requesting node is the node that sends out the original read or write request.
 Like in any other directory-based protocol, it is necessary to send the
 request to the directory node in order to find out where the data actually
 is, what state the directory block is in, and whether or not the request
 can be satisfied immediately.
 In the BIP, all requests pass through the home node and each node can only
 emit one response in reply to a request.
\end_layout

\begin_layout Standard
This basic directory protocol is easier to implement than some of the more
 advanced and newer version of the protocol, but it is also unoptimized.
 This protocol makes sure that each request has a corresponding reply and
 that no operations can proceed until the responding message has been received.
 No assumptions are made when deciding the directory state because we wait
 for the owner or shared block to return to the directory before we forward
 it back to the requester.
\end_layout

\begin_layout Subsubsection
BIP Directory FSM
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/regular-directory-fsm-1.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
BIP directory FSM
\shape default
\emph default

\begin_inset CommandInset label
LatexCommand label
name "fig:regular-protocol-directory-fsm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:regular-protocol-directory-fsm"

\end_inset

 illustrates the directory FSM for the BIP.
 The directory for any address starts in the 
\begin_inset Quotes eld
\end_inset

Unowned
\begin_inset Quotes erd
\end_inset

 state initially.
 When the directory receives a read request, it would set requester as the
 owner, forward the request to the memory node, and transition to 
\begin_inset Quotes eld
\end_inset

Exclusive Waiting for Reply.
\begin_inset Quotes erd
\end_inset

 In that state, the directory has to wait for a response from the memory
 node before it can do anything else, so any read requests that arrive gets
 nakked.
 No writeback requests can arrive in 
\begin_inset Quotes eld
\end_inset

Unowned
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Exclusive Waiting for Reply,
\begin_inset Quotes erd
\end_inset

 because no node has the block, yet.
 When the directory receives a reply from the memory node in 
\begin_inset Quotes eld
\end_inset

Exclusive Waiting for Reply,
\begin_inset Quotes erd
\end_inset

 an exclusive reply is sent to the requester, and the directory transitions
 into the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state.
\end_layout

\begin_layout Standard
From the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state, there are a myriad of situations that can occur.
 The first can happen when an exclusive read request arrives at the directory
 and the requester is the owner.
 This situation occurs when the cache has the block in its 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, but it wants exclusive access to it for a write.
 The directory has to send a read ack (no data) to the requester when this
 happens.
 The second can happen when a writeback request is emitted from the owner.
 In this case, the directory will clear the owner list, send the write to
 memory, send a writeback ack to the requester, and transition to 
\begin_inset Quotes eld
\end_inset

Unowned.
\begin_inset Quotes erd
\end_inset

 The third is when the directory receives an eviction request in this state.
 The directory is required to send an eviction ack to the requester, clear
 the owner list, and transition to 
\begin_inset Quotes eld
\end_inset

Unowned.
\begin_inset Quotes erd
\end_inset

 It is not necessary to write to memory in this case, because an eviction
 request indicates that the message came from a cache whose state was 
\begin_inset Quotes eld
\end_inset

Clean Exclusive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Another type of transition that occurs from the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state is when the directory receives an exclusive read and the requester
 is not the owner.
 In this situation, the directory would set the requester as the owner and
 send an invalidate to the previous owner, while transitioning to 
\begin_inset Quotes eld
\end_inset

Waiting for Invalidate Response,
\begin_inset Quotes erd
\end_inset

 where it waits for a writeback request, an eviction request, or an invalidate
 ack to cause it to transition back to 
\begin_inset Quotes eld
\end_inset

Exclusive.
\begin_inset Quotes erd
\end_inset

 If a read request arrives while the directory is in 
\begin_inset Quotes eld
\end_inset

Waiting for Invalidate Response,
\begin_inset Quotes erd
\end_inset

 the directory would send a nak to the requester.
 If the directory receives a writeback request, it would send an exclusive
 reply to the new owner, a writeback ack to the requester, send a write
 to memory, and transition to 
\begin_inset Quotes eld
\end_inset

Exclusive.
\begin_inset Quotes erd
\end_inset

 On the other hand, if only an eviction request was received, the directory
 would send an exclusive reply to the new owner, send an eviction ack to
 the requester, and transition to 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 without sending a write to memory.
 In 
\begin_inset Quotes eld
\end_inset

Waiting for Invalidate Response,
\begin_inset Quotes erd
\end_inset

 the directory could also receive an invalidate response or an invalidate
 ack.
 In both cases, the directory would send an exclusive reply to the new owner
 and transition to 
\begin_inset Quotes eld
\end_inset

Exclusive,
\begin_inset Quotes erd
\end_inset

 but it would only send a write to memory if it received an invalidate response,
 indicating that the cache was in the 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 state.
\end_layout

\begin_layout Standard
It is also possible to transition from the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state to 
\begin_inset Quotes eld
\end_inset

Exclusive Shared Waiting for Reply
\begin_inset Quotes erd
\end_inset

 when the directory receives a shared read.
 This shared read has to come from a requester that is not the owner.
 The directory has to forward the request to the previous owner and add
 the requester as a sharer.
 In 
\begin_inset Quotes eld
\end_inset

Exclusive Shared Waiting for Reply,
\begin_inset Quotes erd
\end_inset

 several things can happen.
 If the directory receives a read, it would send a nak to the requester.
 If a writeback request arrives from the previous owner, then the directory
 would set the owner to be the read requester, send a writeback ack to the
 writeback requester, send an exclusive read reply to the read requester,
 send a write to memory, and transition back to 
\begin_inset Quotes eld
\end_inset

Exclusive.
\begin_inset Quotes erd
\end_inset

 Receiving an eviction request is similar to receiving a writeback request,
 except the directory does not have to send a write to memory.
 Otherwise, if it receives a read reply from the previous owner, then the
 directory would forward a shared reply to the requester and transition
 to 
\begin_inset Quotes eld
\end_inset

Shared.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, if the directory receives an eviction request from a sharer and
 there are more than two sharers, then the directory would simply remove
 the requester from the sharers list and send an eviction ack to the requester.
 If the directory receives a writeback request and the size of the sharers
 list is 2, then the directory would set the owner to the remaining sharer,
 clear the sharers list, send an eviction ack to the requester, and transition
 to 
\begin_inset Quotes eld
\end_inset

Exclusive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
When a shared read arrives in the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, the directory would add the requester into the sharers list, forward
 the request to a sharer S, which can be any node among the available sharers,
 and transition to 
\begin_inset Quotes eld
\end_inset

Shared Waiting for Reply.
\begin_inset Quotes erd
\end_inset

 In this state, the directory adds any new shared requesters into the sharers
 list and naks any exclusive reads and eviction requests that are not from
 sharer S.
 If the directory receives a shared reply from sharer S in this state, it
 would send shared replies to all requesters.
 However, if an eviction request from sharer S was received, then the directory
 would send shared replies to all read requesters, send an eviction ack
 to the eviction requester, remove the eviction requester from the sharers
 list, and transition back to 
\begin_inset Quotes eld
\end_inset

Shared.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
While in 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, it is also possible to receive an exclusive read request.
 This request causes the requester to be set as the owner, a transition
 to 
\begin_inset Quotes eld
\end_inset

Waiting to Send Invalidates,
\begin_inset Quotes erd
\end_inset

 and the request to be forwarded to a sharer S, which can be any node among
 the available sharers.
 In the 
\begin_inset Quotes eld
\end_inset

Waiting to Send Invalidates
\begin_inset Quotes erd
\end_inset

 state, if the directory receives an eviction request not from sharer S,
 it would send a nak to the requester.
 Likewise, if the directory receives a read request in this state, it would
 send a nak to the requester.
 If a read reply arrives from sharer S, the directory would send invalidates
 to all sharers and transition to 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far,
\begin_inset Quotes erd
\end_inset

 where K is the number of invalidates sent, and J is the number of invalidate
 acks received so far.
 However, if an eviction request from sharer S arrives, then the directory
 would remove the requester from the sharers list, send invalidates to the
 remaining sharers, send an eviction ack to the requester, then transition
 to 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The directory's primary purpose is to wait for invalidate acks in 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far.
\begin_inset Quotes erd
\end_inset

 If a read request or an eviction request was received, the directory has
 to send a nak to the requester.
 If an invalidate ack was received, the directory checks if J (the number
 of invalidate acks received so far) is equal to K (the number of invalidates
 sent).
 If they are not the same, then the directory continues to wait in this
 state.
 However, if J = K, then the directory would send an exclusive reply to
 the requester and transition to 
\begin_inset Quotes eld
\end_inset

Exclusive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
BIP Cache FSM
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/regular-cache-fsm-1.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
BIP cache FSM
\begin_inset CommandInset label
LatexCommand label
name "fig:Regular-protocol-cache"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Regular-protocol-cache"

\end_inset

 illustrates the cache FSM for the BIP.
 All caches start initially in the 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 state.
 From this state, the cache can receive a request from the processor for
 either a shared read or an exclusive read.
 If the cache receives a shared read, then it would transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Reply
\begin_inset Quotes erd
\end_inset

 after forwarding the request to the directory.
 However, if the cache receives an exclusive read, it would transition to
 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Reply
\begin_inset Quotes erd
\end_inset

 after forwarding the request to the directory.
\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Reply,
\begin_inset Quotes erd
\end_inset

 the cache waits for either type of read replies and transitions depending
 on which type of read reply it receives.
 If it receives a nak, it has to resend the shared read request.
 If the cache receives a shared reply, it would fill the cache with the
 block and transition to 
\begin_inset Quotes eld
\end_inset

Shared.
\begin_inset Quotes erd
\end_inset

 However, if the cache receives an exclusive reply, it would transition
 to 
\begin_inset Quotes eld
\end_inset

Clean Exclusive,
\begin_inset Quotes erd
\end_inset

 instead.
\end_layout

\begin_layout Standard
Once in 
\begin_inset Quotes eld
\end_inset

Clean Exclusive,
\begin_inset Quotes erd
\end_inset

 the cache can receive an invalidate message from the directory, when it
 has to reply with an invalidate ack and transition to 
\begin_inset Quotes eld
\end_inset

Invalid.
\begin_inset Quotes erd
\end_inset

 The cache could also receive a shared read request from the directory,
 indicating that the cache should transition into the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state and send a shared reply to the directory.
 In addition, the cache could decide to evict the block by sending an eviction
 request to the directory and transitioning to 
\begin_inset Quotes eld
\end_inset

Clean Exclusive Waiting for Eviction Ack,
\begin_inset Quotes erd
\end_inset

 where it waits for an eviction ack before transitioning to 
\begin_inset Quotes eld
\end_inset

Invalid.
\begin_inset Quotes erd
\end_inset

 Otherwise, the cache can also transition into the 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 state if it receives an exclusive read request from the processor.
\end_layout

\begin_layout Standard
After arriving in the 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 state, several things can happen.
 The cache can receive an invalidate from the directory, when it would have
 to transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 and send an invalidate response with the block attached to the directory.
 If the cache has to evict the block, it would send a writeback request
 to the directory and transition into 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive Waiting for Writeback Ack,
\begin_inset Quotes erd
\end_inset

 where it waits for a writeback ack from the directory before transitioning
 to 
\begin_inset Quotes eld
\end_inset

Invalid.
\begin_inset Quotes erd
\end_inset

 In 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive,
\begin_inset Quotes erd
\end_inset

 the cache could also receive a shared read request from the directory,
 indicating that the cache should transition into the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state and send a shared reply to the directory.
\end_layout

\begin_layout Standard
Once the cache transitions into the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, several transitions could happen.
 The directory could 
\begin_inset space \space{}
\end_inset

receive an invalidate message from the directory, indicating that the cache
 should transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 and send an invalidate ack to the directory.
 If this cache received an invalidate, then this cache could not have been
 the sharer S that the directory chose to read from, since the directory
 is required to obtain the first read reply from sharer S before sending
 out its invalidates.
 In addition, if the cache has to evict a block in the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state for any reason, it would send an eviction request to the directory
 and transition to 
\begin_inset Quotes eld
\end_inset

Shared Waiting for Eviction Ack.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
After transitioning to 
\begin_inset Quotes eld
\end_inset

Shared Waiting for Eviction Ack,
\begin_inset Quotes erd
\end_inset

 the cache has to wait for one of two messages.
 If the cache receives an invalidate message from the directory, then it
 means that the eviction request has not arrived at the directory before
 the invalidate message was sent, so it has to transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Nak,
\begin_inset Quotes erd
\end_inset

 since the directory would send a nak in response to the cache's eviction
 request.
 Once the cache receives a nak in 
\begin_inset Quotes eld
\end_inset

Waiting for Nak,
\begin_inset Quotes erd
\end_inset

 it would send an invalidate ack and transition to 
\begin_inset Quotes eld
\end_inset

Invalid.
\begin_inset Quotes erd
\end_inset

 It is also possible for the cache to receive an eviction ack while in 
\begin_inset Quotes eld
\end_inset

Shared Waiting for Eviction Ack,
\begin_inset Quotes erd
\end_inset

 where the cache can transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 without doing anything else.
\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

Shared,
\begin_inset Quotes erd
\end_inset

 it is also possible for the cache to receive an exclusive read request
 from the processor, where it would forward the request to the directory
 and transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Reply.
\begin_inset Quotes erd
\end_inset

 In this state, the cache can receive a nak from the directory, telling
 the cache that the directory is busy and that it should resend its request.
 Only the exclusive reply message from the directory will transition the
 cache out of this state and into the 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 state.
\end_layout

\begin_layout Subsection
Origin Protocol
\end_layout

\begin_layout Standard
In this section, I will be showing a more optimized version of the cache
 coherence protocol.
 The SGI Origin 2000 implemented this protocol, which is based on an altered
 version of the protocol used in the Stanford DASH multiprocessor
\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
 In this protocol, it is possible for each node to emit two messages in
 response to a request, and not all requests have to pass through the directory
 before being satisfied.
 This allows the Origin protocol to send less messages into the network
 than BIP.
 This decreases the overall latency in the system because it eliminates
 the time going from the data node to the directory node to complete requests.
 The protocol assumes that all read requests to the directory can be satisfied,
 and if it cannot, it is up to the owner of the data instead of the directory
 to send an additional invalidate back to the directory as well as the data
 response to the original requesting node.
 We save time by allowing the data packet retrieved to go directly to the
 requester without the additional latency of going to the directory first.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/cache-coherence-protocol-origin.wmf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Origin protocol
\begin_inset CommandInset label
LatexCommand label
name "fig:Origin-protocol"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Origin-protocol"

\end_inset

 shows a simple request that could occur in the Origin protocol.
 In the Origin protocol, there are also three logical nodes, like in BIP,
 but occasionally, the data node needs to send two messages at once, one
 to the directory node, and one to the requesting node.
 This type of protocol introduce many opportunities for the messages to
 arrive out-of-order.
 A requesting message goes to the directory, which can be different than
 the node that ultimately supplies the response back to the requester.
 There are situations where the directory completes its transition into
 a non-busy state before knowing for certain that the new owner has received
 its request, making it possible for the directory to send another request
 to the new owner when the new owner has not even received its response
 from the previous transaction.
 In addition, the system sometimes need to send out two messages simultaneously,
 as opposed to the BIP, where all operations can only cause one outgoing
 message to be sent on every incoming message.
 The protocol deals with this situation by having the directory change to
 a busy state whenever the directory state and the request cannot be satisfied
 immediately.
 For example, this situation can happen when the directory state is Exclusive
 with another owner, and a read request arrives.
 Any further requests that the directory receives, regardless of their origin
 or type, will be denied via a nak by the directory.
 This ensures that the directory stays in a consistent state and is not
 modified based on an invalid directory state.
\end_layout

\begin_layout Standard
This protocol is also different from BIP in the way it handles invalidations.
 Invalidates have to be sent when transitioning out of the shared state
 into the exclusive state or the invalid state.
 When this occurs in BIP, the invalidate acks return to the directory, and
 the directory would only send out a response to the read request when it
 receives all the invalidate acks.
 If the same thing occurs in the Origin protocol, the invalidate acks return
 to the new owner.
 Therefore, the cache is the component that needs to remember the number
 of invalidate acks received in the Origin protocol.
 Because of these changes, the finite-state machines for this protocol is
 substantially different than the BIP, both in the directory and in the
 cache.
\end_layout

\begin_layout Subsubsection
Origin Protocol Directory FSM
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/origin-fsm-directory-03-combined.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Origin protocol directory FSM
\begin_inset CommandInset label
LatexCommand label
name "fig:Origin-protocol-directory"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Origin-protocol-directory"

\end_inset

 illustrates the directory FSM for the Origin directory-based cache coherence
 protocol and shows all the states in a directory.
 Any block will start in the 
\begin_inset Quotes eld
\end_inset

Unowned
\begin_inset Quotes erd
\end_inset

 state.
 From here, if the directory receives either type of read request, the directory
 would transition to 
\begin_inset Quotes eld
\end_inset

Exclusive (Memory-Access),
\begin_inset Quotes erd
\end_inset

 make requester owner, and perform memory fetch.
 If the directory receives another read request in 
\begin_inset Quotes eld
\end_inset

Exclusive (Memory-Access),
\begin_inset Quotes erd
\end_inset

 the directory would send a nak to the requester.
 When the request from memory returns in the 
\begin_inset Quotes eld
\end_inset

Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state, the directory would send an exclusive reply to the requester and
 transition to the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state.
 It should be impossible for a writeback request to arrive during 
\begin_inset Quotes eld
\end_inset

Unowned
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 states because no node should have the block in these two states.
\end_layout

\begin_layout Standard
From the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, there are several states the directory can transition into.
 The first is 
\begin_inset Quotes eld
\end_inset

Shared (Memory-Access)
\begin_inset Quotes erd
\end_inset

, which occurs if a shared read request comes in while in the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state.
 During the transition, the directory would perform a memory fetch and add
 the requester to sharers.
 In 
\begin_inset Quotes eld
\end_inset

Shared (Memory-Access)
\begin_inset Quotes erd
\end_inset

, the directory would queue up any more shared read requests that might
 come in while sending a nak to any exclusive reads.
 When the memory returns, the directory will send shared replies to all
 requesters.
 There could also be a transition to the 
\begin_inset Quotes eld
\end_inset

Shared Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state or the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state from the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state when it receives an exclusive read request, depending on whether
 or not the requester can be found in the owner or sharers of the directory
 block.
 If the requester is the owner or in sharers, then the directory has received
 an upgrade request, which means that the requester already has the data.
 Otherwise, the directory has to fetch the block from memory before it can
 send out invalidates to sharers and previous owner, send out exclusive
 reply with invalidates pending to the requester, set the requester as the
 owner, and clear sharers.
 It is impossible to receive a writeback request in the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state or any of the states that transitions from the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state because no node has exclusive access to the block.
 If more read requests arrive while in the 
\begin_inset Quotes eld
\end_inset

Shared Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state, then the directory has to send a nak to that request.
\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state, the home memory could transition to the 
\begin_inset Quotes eld
\end_inset

Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state if the requester is the owner, while also performing a fetch from
 memory.
 It could also transition to 
\begin_inset Quotes eld
\end_inset

Unowned
\begin_inset Quotes erd
\end_inset

 if it receives a writeback request.
 However, from 
\begin_inset Quotes eld
\end_inset

Exclusive,
\begin_inset Quotes erd
\end_inset

 it could also transition to the two busy memory-access states.
\end_layout

\begin_layout Standard
In all of the busy states, naks are sent in response to any requests, since
 the directory cannot process any additional requests when it is busy.
 The directory will transition to the busy memory-access states when a read
 request arrives during the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state and the owner is not the requester.
 It is necessary, both when transitioning to 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access)
\begin_inset Quotes erd
\end_inset

 and when transitioning to 
\begin_inset Quotes eld
\end_inset

Busy-Exclusive (Memory-Access),
\begin_inset Quotes erd
\end_inset

 to send a memory fetch and set the owner as the requester; however, it
 is only necessary to set the sharers as the previous owner when transitioning
 to 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access)
\begin_inset Quotes erd
\end_inset

 since 
\begin_inset Quotes eld
\end_inset

Busy-Exclusive (Memory-Access) transitions eventually to the 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 state.
 In the 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state, we usually would wait for the memory to return before performing
 any other operations.
 If the directory receives a memory return first, then it would send an
 intervention request to the previous owner, send a speculative reply to
 the requester, and transition to the 
\begin_inset Quotes eld
\end_inset

Busy-Shared
\begin_inset Quotes erd
\end_inset

 state.
 Should a writeback request occur before the memory return, however, the
 directory would transition to the 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access Writeback-Request)
\begin_inset Quotes erd
\end_inset

 state, where we would wait for the memory return and not send any messages
 that we would send when we transition to the 
\begin_inset Quotes eld
\end_inset

Busy-Shared
\begin_inset Quotes erd
\end_inset

 state.
 In the 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access Writeback-Request)
\begin_inset Quotes erd
\end_inset

 state, we would wait for the memory return message, then send a shared
 reply to the owner and a writeback exclusive ack to the requester.
 Another writeback request could not arrive while in the 
\begin_inset Quotes eld
\end_inset

Busy-Shared (Memory-Access Writeback-Request)
\begin_inset Quotes erd
\end_inset

 state because the directory just received a writeback request from the
 only node that had the block.
 The 
\begin_inset Quotes eld
\end_inset

Busy-Exclusive (Memory-Access)
\begin_inset Quotes erd
\end_inset

 state transitions are similar, except we send exclusive messages instead
 of shared messages and we transition to exclusive states.
\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

Busy-Shared
\begin_inset Quotes erd
\end_inset

 state, the directory is waiting for a message from the previous owner of
 the block before transitioning to the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state.
 This could come in the form of a writeback request (if the owner evicted
 the block before the intervention arrives), a shared writeback, or a shared
 transfer (no data).
 If a writeback request or a shared writeback arrives, the directory also
 has to write the block to memory.
 Additionally, a writeback request means that the directory would forward
 that data to the new owner and return a writeback busy ack to the requester.
 It is possible for the intervention to be unsuccessful, however, which
 is indicated by a nak from the previous owner.
 When this happens, the directory would return to 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 while setting the owner to the previous owner and clear the sharers.
 The 
\begin_inset Quotes eld
\end_inset

Busy-Exclusive
\begin_inset Quotes erd
\end_inset

 state is similar, except exclusive messages are sent instead of shared
 messages, the directory transitions back to 
\begin_inset Quotes eld
\end_inset

Exclusive
\begin_inset Quotes erd
\end_inset

 upon successful completion, and upon receiving a nak in 
\begin_inset Quotes eld
\end_inset

Busy-Exclusive,
\begin_inset Quotes erd
\end_inset

 it is not necessary to clear the sharers.
\end_layout

\begin_layout Subsubsection
Origin Protocol Cache FSM
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/origin-fsm-cache-02.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Origin protocol cache FSM
\begin_inset CommandInset label
LatexCommand label
name "fig:Origin-protocol-cache"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Origin-protocol-cache"

\end_inset

 illustrates the cache FSM for the Origin directory-based cache coherence
 protocol.
 This diagram shows the state transitions for the cache.
 Any cache line for an address starts in the 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 state.
 If the cache receives a shared read from the processor, it transitions
 to 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Response
\begin_inset Quotes erd
\end_inset

 and forwards the request to the home memory; if it receives an exclusive
 read instead, it transitions to 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response.
\begin_inset Quotes erd
\end_inset

 In addition, if the cache receives an intervention, it sends an ack to
 the requester and a transfer to the directory.
 The type of the ack and the transfer will be dependent upon whether or
 not a shared intervention is received or an exclusive intervention is received.
 If the cache receives an invalidate in the 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 state, then it means that the cache has evicted the block because of a
 capacity miss, which means that there is no need to invalidate the block
 again because the cache does not have the block.
 However, it is still necessary to send an invalidate ack to the requester
 in accordance with the protocol.
\end_layout

\begin_layout Standard
Once the cache transitions to 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Response,
\begin_inset Quotes erd
\end_inset

 it is possible for the cache to receive a nak from the directory, indicating
 that the directory is currently busy and cannot handle the request, and
 the cache will have to resend its request.
 If it receives a shared reply, the cache would transition to the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, while receiving an exclusive reply would transition the cache into
 
\begin_inset Quotes eld
\end_inset

Clean Exclusive.
\begin_inset Quotes erd
\end_inset

 If the cache receives an intervention message while in the 
\begin_inset Quotes eld
\end_inset

Clean Exclusive
\begin_inset Quotes erd
\end_inset

 state, it has to send an ack to the requester, and send a transfer to the
 directory, before transitioning to 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Invalid,
\begin_inset Quotes erd
\end_inset

 depending on whether or not it was a shared intervention or an exclusive
 intervention.
 It is also possible, while in 
\begin_inset Quotes eld
\end_inset

Clean Exclusive,
\begin_inset Quotes erd
\end_inset

 to receive an exclusive read request, in which case the cache would transition
 to 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive.
\begin_inset Quotes erd
\end_inset

 Finally, if the cache needs to evict a block while in 
\begin_inset Quotes eld
\end_inset

Clean Exclusive,
\begin_inset Quotes erd
\end_inset

 it would transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 without sending any messages.
\end_layout

\begin_layout Standard
However, if a cache receives a speculative reply or a shared response/ack
 in 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Response,
\begin_inset Quotes erd
\end_inset

 then it would transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Response/Ack
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Shared Waiting for Speculative Reply,
\begin_inset Quotes erd
\end_inset

 respectively.
 Receiving either of these messages mean that the directory block state
 was Exclusive and that the requester needs to wait for both messages before
 it can fill its cache and transition to the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state.
 However, it is possible to get a nak from the previous owner while in the
 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Response/Ack
\begin_inset Quotes erd
\end_inset

 state, in which case, the cache has to start all over and resend the request
 while transitioning back to 
\begin_inset Quotes eld
\end_inset

Waiting for Shared Read Response.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

Shared
\begin_inset Quotes erd
\end_inset

 state, if the cache receives an invalidate from the directory, the cache
 would have to invalidate the block, send an invalidate ack to the requester,
 and transition to the 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 state.
 If the cache needs to evict the block, it would also have to transition
 to 
\begin_inset Quotes eld
\end_inset

Invalid,
\begin_inset Quotes erd
\end_inset

 but without sending any messages.
 It is also possible to receive an exclusive read request from the processor
 in this state, when the cache would have to forward the request to the
 directory and transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response.
\begin_inset Quotes erd
\end_inset

 Since the cache might have received the exclusive read request before receiving
 an invalidate from the directory, it is necessary to send an invalidate
 ack to the requester when receiving an invalidate in the 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response
\begin_inset Quotes erd
\end_inset

 state.
 If the cache receives a nak in 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response,
\begin_inset Quotes erd
\end_inset

 the directory could not fulfill the request and the cache must resend its
 request.
 Typically, the cache would receive an exclusive reply in this state and
 transition to 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename diagrams/waiting-for-k-invalidates-j-invalidates-received.emf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scenarios When Transitioning into 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Scenarios-When-Transitioning"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, if there were any sharers when the cache requested exclusive read,
 the cache would receive an exclusive reply with invalidates pending or
 an invalidate ack and transition to 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far.
\begin_inset Quotes erd
\end_inset

 The reason that an exclusive reply with invalidates pending or an invalidate
 ack could be received from the 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response
\begin_inset Quotes erd
\end_inset

 state is illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Scenarios-When-Transitioning"

\end_inset

.
 The exclusive reply with invalidates pending and invalidations are sent
 at the same time to the requester and the sharers, respectively, in both
 scenarios.
 In the expected case, scenario 1, the exclusive reply with invalidates
 pending would arrive at the requester before any invalidate acks.
 However, if any sharers are on the same node as the directory, it can receive
 its invalidate before the exclusive reply with invalidates pending arrives
 at the requester.
 The sharer would then send an invalidate ack to the requester.
 Since the invalidate ack has to traverse the network, there is no guarantee
 that the exclusive reply with invalidates pending would arrive first.
 Therefore, the requester has to prepare for both scenarios by transitioning
 into the 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far
\begin_inset Quotes erd
\end_inset

 state on the arrival of either types of messages.
 In this state, the cache waits for the arrival of invalidate acks and/or
 exclusive reply with invalidates pending and transitions to 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 only when all invalidate acks and the exclusive reply with invalidates
 pending have been received.
 It is also possible to receive an intervention while in 
\begin_inset Quotes eld
\end_inset

Waiting for K Invalidates, J Invalidates Received So Far,
\begin_inset Quotes erd
\end_inset

 when the cache would have to respond with a nak to the directory and a
 nak to the requester.
\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response
\begin_inset Quotes erd
\end_inset

 state, it is also possible that the cache has to wait for two messages
 before it can transition to 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive.
\begin_inset Quotes erd
\end_inset

 When the cache receives an exclusive response/ack or a speculative reply,
 it would transition to 
\begin_inset Quotes eld
\end_inset

Exclusive Waiting for Speculative Reply
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Response/Ack,
\begin_inset Quotes erd
\end_inset

 respectively, while it waits for the other message of this two-message
 exchange to arrive.
 When the other message arrives, the cache would fill the cache with the
 exclusive response (if exclusive response) or speculative reply (if exclusive
 ack) and transition to 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive.
\begin_inset Quotes erd
\end_inset

 However, it is possible that the cache receives a nak from the previous
 owner in the 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Response/Ack
\begin_inset Quotes erd
\end_inset

 state, when the cache would have to start over by resending its request
 to the directory and transitioning to 
\begin_inset Quotes eld
\end_inset

Waiting for Exclusive Read Response.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Once in the 
\begin_inset Quotes eld
\end_inset

Dirty Exclusive
\begin_inset Quotes erd
\end_inset

 state, the cache can receive three types of messages.
 If the cache receives a shared intervention, it would send a shared response
 to the requester and send a shared writeback to the directory while transitioni
ng to 
\begin_inset Quotes eld
\end_inset

Shared.
\begin_inset Quotes erd
\end_inset

 Similarly, if the message was an exclusive intervention, it would send
 an exclusive response to the requester and a dirty transfer to the directory
 while transitioning to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

.
 Furthermore, the cache can also receive a writeback request from the processor
 in this state, where it has to forward the request to the directory and
 transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Writeback Response.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
If the cache receives a simple writeback exclusive ack in 
\begin_inset Quotes eld
\end_inset

Waiting for Writeback Response,
\begin_inset Quotes erd
\end_inset

 the cache can transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

 without any other operations.
 If the cache receives an intervention, it would transition to 
\begin_inset Quotes eld
\end_inset

Waiting for Writeback Busy Ack,
\begin_inset Quotes erd
\end_inset

 where it would wait for a writeback busy ack before transitioning to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

.
 Similarly, if the cache receives a writeback busy ack first, it would transitio
n to 
\begin_inset Quotes eld
\end_inset

Waiting for Intervention
\begin_inset Quotes erd
\end_inset

 and wait for the intervention before it can transition to 
\begin_inset Quotes eld
\end_inset

Invalid
\begin_inset Quotes erd
\end_inset

.
 It is also possible that the directory is in one of the busy states while
 the cache is 
\begin_inset Quotes eld
\end_inset

Waiting for Writeback Response,
\begin_inset Quotes erd
\end_inset

 and the cache has to resend its writeback request if that happens.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section

\family roman
Results
\end_layout

\begin_layout Standard
In this section, I will discuss the results of running the simulation on
 the SESC simulator.
 The results are shown in Table 2 for the results using the benchmark fft
 in the SPLASH-2 benchmark suite with 32 processors.
 The fft benchmark is a complex 1-D version of the radix-
\begin_inset Formula ${\surd}$
\end_inset

n six-step FFT algorithm, which is optimized to minimize inter-processor
 communication
\begin_inset CommandInset citation
LatexCommand cite
key "WOO00"

\end_inset

.
 The implementation of the code was done SESC Simulator, which uses C++
 as its programming language.
 It supports various features of a computer system that allows us to simulate
 the differences between different directory-based protocols.
\end_layout

\begin_layout Subsection

\family roman
SESC Simulator
\end_layout

\begin_layout Standard
The connections in the SESC Simulator are shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset

 [still have to add this].
 We are using an architecture with a 1K L1 cache and a 2K L2 cache.
\end_layout

\begin_layout Subsection

\family roman
Verifying Correctness
\end_layout

\begin_layout Standard
To verify whether or not the simulator is correct, we run the benchmark
 on a normal machine to find out what the output is, then run the program
 on SESC.
 The output produced from SESC should be identical to that produced by running
 the benchmark on a real processor.
 If not, then it means that the program that simulates the directory protocol
 is not running correctly.
 In addition, the SPLASH2 benchmarks' kernel programs provide self-test
 that we can invoke to ensure that our protocols were implemented directly.
 It achieves this self-test using inherent tests to the data structure.
\end_layout

\begin_layout Subsection
Synthetic Benchmark
\end_layout

\begin_layout Standard
As proof of concept, I have created a very simple synthetic benchmark to
 illustrate the strength of the Origin protocol.
 This section introduces synthetic benchmarks.
 The synthetic benchmark show in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

? is a program that performs a very large number of writes.
 The test systems using either types of protocols have two processors, and
 both the processors are trying to write to the same location.
 This should force the block to continuously get evicted, which will test
 the effectiveness of the Origin protocol in reducing latency by allowing
 the data node to reply directly to the requesting node, without having
 to send the message first to the directory.
\end_layout

\begin_layout Subsection

\family roman
SPLASH2 benchmarks
\end_layout

\begin_layout Standard
Using these results, we can see that the MSI protocol takes longer to complete.
 Although there are more read misses for the MESI cache, it is offset by
 the amount of read hits for L2 cache.
 
\begin_inset space \space{}
\end_inset

It could also be possible that the additional read misses do not incur as
 much penalty in a MESI cache because in a MESI cache, there is a greater
 opportunity for the cache to fetch the data from another node in that directory
 instead of from the memory.
\end_layout

\begin_layout Standard

\family roman
We also see that for both MESI and MSI caches, as the CPU count increases,
 the run-time decreases, this is to be expected as more work can be done
 in the same amount of time when one has more processors that can be used
 at the same time.
\end_layout

\begin_layout Standard
The speedup is caused by increases in cache size.
 The increase in cache size resulted in a reduction of misses.
 As we can see, the misses in the system can directly affect the runtime
 of the system.
 The higher the number of misses there are, the longer the system takes
 to finish.
 The results from averaging the benchmarks show that the Origin protocol
 is superior in virtually all cases.
 Unless otherwise specified, the resultant runs from simulations are done
 with 32 processors, with 
\end_layout

\begin_layout Subsubsection

\family roman
Changing Cache Size
\end_layout

\begin_layout Standard
The cache size can be determined by associativity * number of sets * width.
 Therefore, in the configuration file, it is only necessary to give these
 three parameters and not the total size of the cache.
 For example, in my system, this could be 4 * 4 * 64, in the case of the
 L1 cache.
 This gives it 16 blocks of 64-bit data to have a 1kB L1 cache.
 In the case of the L2 cache, I used an associativity of 4 with 8 sets to
 get 32 blocks.
 this equates to a 2kB cache.
\end_layout

\begin_layout Standard
Increasing cache size increases coherence misses because more invalidates
 occur because fewer blocks are bumped due to capacity misses.
 Of course, capacity misses decrease because the cache has more spaces to
 put blocks
\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
 Increasing block size means capacity miss decreases and compulsory miss
 decreases for certain applications.
 When this happens, it most likely means that there is a lot of spatial
 locality in the code, such as when running kernel code.
 Because increasing block size grabs more of the code in the same area together,
 which directly reduces compulsory misses.
 The capacity miss is reduced because we're storing more of the necessary
 code in the cache
\begin_inset CommandInset citation
LatexCommand cite
key "HEN00"

\end_inset

.
\end_layout

\begin_layout Section

\family roman
Problems
\end_layout

\begin_layout Standard
In implementing the directory-based cache coherence protocol, there were
 some problems.
 One was simply that debugging such a large system is inherently hard, especiall
y since the bugs often surface after tens of thousands of messages are sent.
 It is useful to print out each message that pass around the system.
 To debug these problems, it is useful to know which messages cause which
 transitions.
 For example, if we see that a message is being sent to the directory node
 when it should be sent to the requesting node, we know that there is a
 problem.
 The debugging system works by various lines of assertions that should always
 hold true if the system is working.
 They can easily be turned off to increase speed of the simulator by not
 defining DEBUG when compiling.
\end_layout

\begin_layout Standard
In addition, the memory system in the current system is implemented in a
 way such that it is in one location.
 In the future, we could modify the the simulator such that the memory system
 is distributed just like the directory system.
 With a distributed memory system, there would be much more issue with coherence
, scaling, performance, and correctness.
\end_layout

\begin_layout Standard
We can compare the protocol we have to a snarfing protocol.
 In this protocol, the cache controller watches both address and data in
 an attempt to update its own copy of a memory location when a second master
 modifies a location in main memory.
 When a write operation is observed to a location that a cache has a copy
 of, the cache controller updates its own copy of the snarfed memory location
 with the new data
\begin_inset CommandInset citation
LatexCommand cite
key "FAR00"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "LAU00"

\end_inset

.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We have arrived at the conclusion that the Origin-based directory protocol
 is superior, since a few of its transactions can be done using a three-way
 interaction instead of two bilateral interactions.
 
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "report2"
options "unsrt"

\end_inset

 
\end_layout

\end_body
\end_document
